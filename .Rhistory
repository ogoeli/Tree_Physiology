# Look at the distribution of samples for each factor
table(trend_summer_2025[ , c("SP_CODE", "PLOT")])
##check for collinairty
# Select the relevant columns
predictors <- trend_summer_2025[, c("min_temp", "max_temp", "soil_moisture_am", "evapotranspiration", "vpd", "precipitation")]
# Check pairwise correlations
cor_matrix <- cor(predictors, use = "complete.obs")  # exclude missing values
print(cor_matrix)
# Log-transform (common for right-skewed positive variables)
trend_all$z_max_temp <- scale(trend_all$max_temp)
trend_all$z_soil_moisture_am <- scale(trend_all$soil_moisture_am + 1)  # add 1 if zeros exist
trend_all$z_evapotranspiration <- scale(trend_all$evapotranspiration + 1)
trend_all$z_precipitation <- scale(trend_all$precipitation + 1)
summary(trend_all)
trend_all$z_vpd <- scale(trend_all$vpd + 1)
summary(trend_all)
##chewck for variance between plot
lm_res <- lm(DV ~  max_temp + soil_moisture_am + vpd + evapotranspiration + precipitation, data = trend_all, na.action = na.omit)
summary(lm_res)
##chewck for variance between plot
lm_res <- lm(TWD ~  max_temp + soil_moisture_am + vpd + evapotranspiration + precipitation, data = trend_all, na.action = na.omit)
summary(lm_res)
##check for collinairty
# Select the relevant columns
predictors <- trend_summer_2025[, c("max_temp", "soil_moisture_am", "evapotranspiration", "vpd", "precipitation")]
# Check pairwise correlations
cor_matrix <- cor(predictors, use = "complete.obs")  # exclude missing values
print(cor_matrix)
# Fit LME with tree nested in species and location as random effects
# You can start simple: random intercept per tree
M1.TWD <- lme(
TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
random = ~1 | Dendro_number,   # random intercept per tree
method = "REML",
na.action = na.omit,
data = trend_all
)
summary(M1.TWD)
#model without correlation of time
TWD_gls <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd + Date,
data = trend_all,
na.action = na.omit,
method = "ML")
tab_model(TWD_gls, show.aic = TRUE, show.se = TRUE)
acf(residuals(TWD_gls, type = "normalized"))
pacf(residuals(TWD_gls, type = "normalized"))
#Compound symmetry (constant correlation)
birds_cs <- update(TWD_gls,
correlation = corCompSymm(form = ~ Date))
#model without correlation of time
TWD_gls <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd + Date,
weight = varIdent(form = ~ 1 | Dendro_number),
data = trend_all,
na.action = na.omit,
method = "ML")
#model without correlation of time
TWD_gls <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd + Date,
weights = varIdent(form = ~ 1 | Dendro_number),
data = trend_all,
na.action = na.omit,
method = "ML")
#model without correlation of time
TWD_gls <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd + Date,
#weights = varIdent(form = ~ 1 | Dendro_number),
data = trend_all,
na.action = na.omit,
method = "ML")
trend_all$Dendro_number <- as.factor(trend_all$Dendro_number)
#model without correlation of time
TWD_gls <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd + Date,
weights = varIdent(form = ~ 1 | Dendro_number),
data = trend_all,
na.action = na.omit,
method = "ML")
#model without correlation of time
TWD_gls <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd + Date,
#weights = varIdent(form = ~ 1 | Dendro_number),
data = trend_all,
na.action = na.omit,
method = "ML")
tab_model(TWD_gls, show.aic = TRUE, show.se = TRUE)
acf(residuals(TWD_gls, type = "normalized"))
pacf(residuals(TWD_gls, type = "normalized"))
#Compound symmetry (constant correlation)
birds_cs <- update(TWD_gls,
correlation = corCompSymm(form = ~ Date))
#model without correlation of time
TWD_gls <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd + Date,
#weights = varIdent(form = ~ 1 | Dendro_number),
data = trend_all,
na.action = na.omit,
method = "ML")
TWD_gls_2 <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
weights = varIdent(form = ~ 1 | Dendro_number),
data = trend_all,
na.action = na.omit,
method = "ML")
# Fit LME with tree nested in species and location as random effects
# You can start simple: random intercept per tree
M1.TWD <- lme(
TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
random = ~1 | Dendro_number,   # random intercept per tree
method = "REML",
na.action = na.omit,
data = trend_all
)
AIC(TWD_gls, TWD_gls_2, M1.TWD)
common_data <- na.omit(trend_all[, c(
"TWD",
"z_max_temp", "z_soil_moisture_am", "z_evapotranspiration", "z_precipitation", "z_vpd",
# add any other predictors used in the 3 models
"Date", "Dendro_number"
)])
#model without correlation of time
TWD_gls <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd + Date,
#weights = varIdent(form = ~ 1 | Dendro_number),
data = common_data,
na.action = na.omit,
method = "ML")
TWD_gls_2 <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
weights = varIdent(form = ~ 1 | Dendro_number),
data = common_data,
na.action = na.omit,
method = "ML")
# Fit LME with tree nested in species and location as random effects
# You can start simple: random intercept per tree
M1.TWD <- lme(
TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
random = ~1 | Dendro_number,   # random intercept per tree
method = "REML",
na.action = na.omit,
data = common_data
)
AIC(TWD_gls, TWD_gls_2, M1.TWD)
#model without correlation of time
TWD_gls <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd + Date,
#weights = varIdent(form = ~ 1 | Dendro_number),
data = common_data,
na.action = na.omit,
method = "ML")
TWD_gls_2 <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
weights = varIdent(form = ~ 1 | Dendro_number),
data = common_data,
na.action = na.omit,
method = "ML")
# Fit LME with tree nested in species and location as random effects
# You can start simple: random intercept per tree
M1.TWD <- lme(
TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
random = ~1 | Dendro_number,   # random intercept per tree
method = "REML",
na.action = na.omit,
data = common_data
)
AIC(TWD_gls, TWD_gls_2, M1.TWD)
# Fit LME with tree nested in species and location as random effects
# You can start simple: random intercept per tree
M1.TWD <- lme(
TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
random = ~1 | Dendro_number,   # random intercept per tree
method = "ML",
na.action = na.omit,
data = common_data
)
AIC(TWD_gls, TWD_gls_2, M1.TWD)
#model without correlation of time
TWD_gls <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd + Date,
#weights = varIdent(form = ~ 1 | Dendro_number),
data = common_data,
na.action = na.omit,
method = "ML")
TWD_gls_2 <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd + Date,
weights = varIdent(form = ~ 1 | Dendro_number),
data = common_data,
na.action = na.omit,
method = "ML")
library(sf)
library(zoo)
library(Kendall)
library(trend)
library(lme4)
library(sjPlot)
library(nlme)
library(effects)
library(ggeffects)
library(RColorBrewer)
#library(flextable)
library(knitr)
library(officer)
library(webshot2)
#install.packages("systemfonts")
library(nnet)
library(MASS)
library(performance)
library(GGally)
library(tidyverse)
AIC(TWD_gls, TWD_gls_2, M1.TWD)
TWD_gls_2 <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd + Date,
weights = varIdent(form = ~ 1 | Dendro_number),
data = common_data,
na.action = na.omit,
method = "ML")
TWD_gls_2 <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
weights = varIdent(form = ~ 1 | Dendro_number),
data = common_data,
na.action = na.omit,
method = "ML")
tab_model(TWD_gls_2, show.aic = TRUE, show.se = TRUE)
#model without correlation of time
TWD_gls <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
#weights = varIdent(form = ~ 1 | Dendro_number),
data = common_data,
na.action = na.omit,
method = "ML")
tab_model(TWD_gls_2, show.aic = TRUE, show.se = TRUE)
acf(residuals(TWD_gls_2, type = "normalized"))
pacf(residuals(TWD_gls_2, type = "normalized"))
#Compound symmetry (constant correlation)
birds_cs <- update(TWD_gls_2,
correlation = corCompSymm(form = ~ Date))
TWD_gls_2 <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
weights = varIdent(form = ~ 1 | Dendro_number),
correlation = corCompSymm(form = ~ Date),
data = common_data,
na.action = na.omit,
method = "ML")
TWD_gls_2 <- gls( TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
weights = varIdent(form = ~ 1 | Dendro_number),
correlation = corCompSymm(form = ~ Date),
data = common_data,
na.action = na.omit,
method = "ML")
## Apply by Dendro_number
trend_results <- merged_data %>%
group_by(Dendro_number) %>%
summarise(
tmp = list(check_trend(TWD)),
.groups = "drop"
) %>%
tidyr::unnest_wider(tmp)  # expands Trend and Slope into separate columns
table(trend_results$Trend)
## Merge back with main data
trend_all <- merged_data %>%
left_join(trend_results, by = "Dendro_number") %>%
mutate(Trend = Trend)  # keep trend label for each record
# Load CSV
summer_2025 <- read.csv("/scratch/ope4/BIO_599/SUMMER/SUMMER_2025.csv")
colnames(summer_2025)
summer_2025 <- summer_2025 |>
select(Dendrometer,SP_CODE, PLOT) |>
na.omit()
##join summer 2025 dataset to our full datset
trend_summer_2025 <- trend_all %>%
left_join(summer_2025, by = c("Dendro_number" = "Dendrometer"))
##look at summary stat
summary(trend_summer_2025)
# Look at the distribution of samples for each factor
table(trend_summer_2025[ , c("SP_CODE", "PLOT")])
##check for collinairty
# Select the relevant columns
predictors <- trend_summer_2025[, c("min_temp", "max_temp", "soil_moisture_am", "evapotranspiration", "vpd", "precipitation")]
# Check pairwise correlations
cor_matrix <- cor(predictors, use = "complete.obs")  # exclude missing values
print(cor_matrix)
# Log-transform (common for right-skewed positive variables)
trend_all$z_max_temp <- scale(trend_all$max_temp)
trend_all$z_soil_moisture_am <- scale(trend_all$soil_moisture_am + 1)  # add 1 if zeros exist
trend_all$z_evapotranspiration <- scale(trend_all$evapotranspiration + 1)
trend_all$z_precipitation <- scale(trend_all$precipitation + 1)
trend_all$z_vpd <- scale(trend_all$vpd + 1)
summary(trend_all)
##chewck for variance between plot
lm_res <- lm(TWD ~  max_temp + soil_moisture_am + vpd + evapotranspiration + precipitation, data = trend_all, na.action = na.omit)
# Fit LME with tree nested in species and location as random effects
# You can start simple: random intercept per tree
M1.TWD <- lme(
TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
random = ~1 | Dendro_number,   # random intercept per tree
method = "REML",
na.action = na.omit,
data = trend_all
)
summary(M1.TWD)
TWD_png <- tab_model(M1.TWD)
TWD_png
#DV
M1.DV <- lme(
DV ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation+ z_vpd,
random = ~1 | Dendro_number,   # random intercept per tree
method = "REML",
na.action = na.omit,
data = trend_all
)
summary(M1.DV)
DV_png <- tab_model(M1.DV)
DV_png
TWD_png
##look at how the species and plot play a role in TWD
##model mixed model for plot and sp
# TWD with same structure
trend_summer_2025$SP_CODE <- as.factor(trend_summer_2025$SP_CODE)
trend_summer_2025$PLOT <- as.factor(trend_summer_2025$PLOT)
# Log-transform (common for right-skewed positive variables)
trend_summer_2025$z_max_temp <- scale(trend_summer_2025$max_temp)
trend_summer_2025$z_soil_moisture_am <- scale(trend_summer_2025$soil_moisture_am + 1)  # add 1 if zeros exist
trend_summer_2025$z_evapotranspiration <- scale(trend_summer_2025$evapotranspiration + 1)
trend_summer_2025$z_precipitation <- scale(trend_summer_2025$precipitation + 1)
summary(trend_summer_2025)
View(summer_2025)
##join summer 2025 dataset to our full datset
trend_summer_2025 <- trend_all %>%
left_join(summer_2025, by = c("Dendro_number" = "Dendrometer"))
View(trend_summer_2025)
trend_summer_2025
trend_all
summer_2025
##join summer 2025 dataset to our full datset
trend_summer_2025 <- trend_all %>%
left_join(summer_2025, by = c("Dendro_number" = "Dendrometer"))
trend_all
summer_2025
trend_summer_2025
##join summer 2025 dataset to our full datset
summer_2025_clean <- summer_2025 %>%
distinct(Dendrometer, SP_CODE, PLOT)
View(summer_2025_clean)
trend_summer_2025 <- trend_all %>%
left_join(summer_2025_clean, by = c("Dendro_number" = "Dendrometer"))
##look at summary stat
summary(trend_summer_2025)
# Look at the distribution of samples for each factor
table(trend_summer_2025[ , c("SP_CODE", "PLOT")])
##check for collinairty
# Select the relevant columns
predictors <- trend_summer_2025[, c("min_temp", "max_temp", "soil_moisture_am", "evapotranspiration", "vpd", "precipitation")]
# Check pairwise correlations
cor_matrix <- cor(predictors, use = "complete.obs")  # exclude missing values
print(cor_matrix)
# Log-transform (common for right-skewed positive variables)
trend_all$z_max_temp <- scale(trend_all$max_temp)
trend_all$z_soil_moisture_am <- scale(trend_all$soil_moisture_am + 1)  # add 1 if zeros exist
trend_all$z_evapotranspiration <- scale(trend_all$evapotranspiration + 1)
trend_all$z_precipitation <- scale(trend_all$precipitation + 1)
trend_all$z_vpd <- scale(trend_all$vpd + 1)
summary(trend_all)
# Fit LME with tree nested in species and location as random effects
# You can start simple: random intercept per tree
M1.TWD <- lme(
TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
random = ~1 | Dendro_number,   # random intercept per tree
method = "REML",
na.action = na.omit,
data = trend_all
)
summary(M1.TWD)
TWD_png <- tab_model(M1.TWD)
TWD_png
#DV
M1.DV <- lme(
DV ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation+ z_vpd,
random = ~1 | Dendro_number,   # random intercept per tree
method = "REML",
na.action = na.omit,
data = trend_all
)
summary(M1.DV)
DV_png <- tab_model(M1.DV)
DV_png
View(trend_all)
# Log-transform (common for right-skewed positive variables)
trend_summer_2025$z_max_temp <- scale(trend_summer_2025$max_temp)
trend_summer_2025$z_soil_moisture_am <- scale(trend_summer_2025$soil_moisture_am + 1)  # add 1 if zeros exist
trend_summer_2025$z_evapotranspiration <- scale(trend_summer_2025$evapotranspiration + 1)
trend_summer_2025$z_precipitation <- scale(trend_summer_2025$precipitation + 1)
trend_summer_2025$z_vpd <- scale(trend_summer_2025$vpd + 1)
summary(trend_summer_2025)
# Fit LME with tree nested in species and location as random effects
# You can start simple: random intercept per tree
M1.TWD <- lme(
TWD ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation + z_vpd,
random = ~1 | Dendro_number,   # random intercept per tree
method = "REML",
na.action = na.omit,
data = trend_summer_2025
)
summary(M1.TWD)
TWD_png <- tab_model(M1.TWD)
TWD_png
#DV
M1.DV <- lme(
DV ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation+ z_vpd,
random = ~1 | Dendro_number,   # random intercept per tree
method = "REML",
na.action = na.omit,
data = trend_summer_2025
)
summary(M1.DV)
DV_png <- tab_model(M1.DV)
DV_png
TWD_png
#DV
M1.DV <- lme(
DV ~ z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation+ z_vpd,
random = ~1 | Dendro_number,   # random intercept per tree
method = "REML",
na.action = na.omit,
data = trend_summer_2025
)
summary(M1.DV)
DV_png <- tab_model(M1.DV)
DV_png
##look at how the species and plot play a role in TWD
##model mixed model for plot and sp
# TWD with same structure
trend_summer_2025$SP_CODE <- as.factor(trend_summer_2025$SP_CODE)
trend_summer_2025$PLOT <- as.factor(trend_summer_2025$PLOT)
#table 2
# Refit the model
M2_TWD <- lme(TWD ~ (z_max_temp + z_soil_moisture_am +
z_evapotranspiration + z_precipitation) * SP_CODE,
random = ~1 | Dendro_number,
data = trend_summer_2025,
method = "REML",
na.action = na.omit)
summary(M2_TWD)
tab_model(M2_TWD)
# Prepare the table
sig_table <- summary(M2_TWD)$tTable %>%
as_tibble(rownames = "variable") %>%
filter(`p-value` < 0.05) %>%
mutate(
# Add stars for significance
signif = case_when(
`p-value` < 0.001 ~ "***",
`p-value` < 0.01  ~ "**",
`p-value` < 0.05  ~ "*"
),
# Round numeric columns
Value     = round(Value, 0),
Std.Error = round(Std.Error, 0),
`t-value` = round(`t-value`, 3),
`p-value` = round(`p-value`, 3),
# Shorten variable names
variable = str_replace(variable, "SP_CODE", ""),
)
# Create flextable
ft <- flextable(sig_table[, c("variable", "Value", "Std.Error", "DF", "t-value", "p-value", "signif")]) %>%
autofit()
ft
library(flextable)
tab_model(M2_TWD)
# Prepare the table
sig_table <- summary(M2_TWD)$tTable %>%
as_tibble(rownames = "variable") %>%
filter(`p-value` < 0.05) %>%
mutate(
# Add stars for significance
signif = case_when(
`p-value` < 0.001 ~ "***",
`p-value` < 0.01  ~ "**",
`p-value` < 0.05  ~ "*"
),
# Round numeric columns
Value     = round(Value, 0),
Std.Error = round(Std.Error, 0),
`t-value` = round(`t-value`, 3),
`p-value` = round(`p-value`, 3),
# Shorten variable names
variable = str_replace(variable, "SP_CODE", ""),
)
# Create flextable
ft <- flextable(sig_table[, c("variable", "Value", "Std.Error", "DF", "t-value", "P value", "signif")]) %>%
autofit()
# Create flextable
ft <- flextable(sig_table[, c("variable", "Value", "Std.Error", "DF", "t-value", "p-value", "signif")]) %>%
autofit()
ft
# Export to Word (can save as PDF from Word)
doc <- read_docx() %>%
body_add_flextable(ft)
print(doc, target = "/scratch/ope4/BIO_599/Figure/Table_2.docx")
