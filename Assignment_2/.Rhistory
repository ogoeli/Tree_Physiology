# Plot
ggplot(df, aes(x = lwc, y = predicted)) +
geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), fill = "pink", alpha = 0.4) +
geom_line(color = "black", size = 1.5) +
labs(
x = "z LWC (standardized leaf water content)",
y = "Predicted Slope",
title = "Effect of LWC on Slope"
) +
theme_minimal(base_size = 14)+
theme(
panel.border = element_rect(color = "black", fill = NA, linewidth = 1.2)
)
library(ggplot2)
# Create a data frame with species effects
species <- c("ABLA","JUMO","JUOS","PIED","PILE","PIPO","PIPU","PIST","PSME","QUEM","QUGA","QUHY")
estimate <- c(-1.11,-1.62,-4.19,-2.35,1.72,-3.58,0.19,-2.81,1.49,-6.85,-0.82,-1.47)
se <- c(2.16,1.46,1.18,1.65,2.08,0.97,1.16,1.07,0.96,1.47,1.10,1.37)
# Calculate 95% CI
ci_upper <- estimate + 1.96*se
ci_lower <- estimate - 1.96*se
# Identify significance
significant <- ifelse(ci_lower * ci_upper > 0, "Yes", "No")
# Data frame
df <- data.frame(species, estimate, ci_lower, ci_upper, significant)
# Reorder species by estimate for nicer plotting
df$species <- factor(df$species, levels = df$species[order(df$estimate)])
# Plot
ggplot(df, aes(x = estimate, y = species, color = significant)) +
geom_point(size = 3) +
geom_errorbarh(aes(xmin = ci_lower, xmax = ci_upper), height = 0.2) +
geom_vline(xintercept = 0, linetype = "dashed", color = "gray") +
scale_color_manual(values = c("Yes" = "pink", "No" = "black")) +
labs(
x = "Effect on TWD Slope (Estimate ± 95% CI)",
y = "Species code",
title = "Species Effects on TWD Slope"
) +
theme_minimal(base_size = 14)+
theme(
panel.border = element_rect(color = "black", fill = NA, linewidth = 1.2)
)
library(sf)
library(zoo)
library(Kendall)
library(trend)
library(lme4)
library(sjPlot)
library(nlme)
library(effects)
library(ggeffects)
library(RColorBrewer)
#library(flextable)
library(knitr)
library(officer)
#library(see)
library(webshot2)
#install.packages("systemfonts")
library(nnet)
library(MASS)
library(performance)
library(tidyverse)
# 1. List all CSV files in the folder
files <- list.files(
path = "/scratch/ope4/BIO_599/dendrometers/",
pattern = "_data_.*\\.csv$",
full.names = TRUE
)
# 2. Function to read a file and add dendro_number
read_dendro_file <- function(file) {
# Read the CSV
sub <- read.csv(file, sep = ";", header = FALSE, stringsAsFactors = FALSE)
# Extract dendro number from filename
dendro_number <- as.numeric(gsub(".*_data_([0-9]+)_.*", "\\1", file))
# Add column
sub$Dendro_number <- dendro_number
return(sub)
}
# 3. Apply to all files and combine into one data frame
all_data <- lapply(files, read_dendro_file) %>% bind_rows()
# select col of interest
combined_data <- all_data |>
select(Dendro_number, V2, V4, V7) |>
filter(V7 != 0)
##rename the cols
colnames(combined_data) <- c("Dendro_number", "DateTime", "Temp", "dendro")
summary(combined_data)
# Convert DateTime to POSIXct if not already
combined_data$DateTime <- as.POSIXct(combined_data$DateTime, format = "%Y.%m.%d %H:%M")
combined_data$Temp <- as.numeric(combined_data$Temp)  # safe if it's already numeric
combined_data$Dendro_number <- as.numeric(combined_data$Dendro_number)  # safe if it's already numeric
str(combined_data)
head(combined_data$DateTime, 20)
# 1. Compute the maximum per dendrometer across all time
dendro_max <- combined_data %>%
group_by(Dendro_number) %>%
summarise(dmax = max(dendro, na.rm = TRUE), .groups = 'drop')
# 2. Join dmax and calculate TWD for each measurement
combined_data <- combined_data %>%
left_join(dendro_max, by = "Dendro_number") %>%
mutate(TWD = dmax - dendro)  # TWD for each 15-min measurement
daily_variation <- combined_data %>%
mutate(Date = as.Date(DateTime)) %>%       # add date-only column
group_by(Dendro_number, Date) %>%         # group by dendrometer and day
summarise(
min_dendro = min(dendro, na.rm = TRUE),
max_dendro = max(dendro, na.rm = TRUE),
DV = max_dendro - min_dendro,
TWD = mean(TWD, na.rm = TRUE),
min_temp = min(Temp, na.rm = TRUE),
max_temp = max(Temp, na.rm = TRUE),
temp_range = max_temp - min_temp,
) %>%
ungroup()
summary(daily_variation)
length(unique(combined_data$Dendro_number))
length(unique(daily_variation$Dendro_number))
#add the climate dataset
precip <- read_csv("/scratch/ope4/BIO_599/Dendro Climate Points/precipitation_time_series.csv")
summary(precip)
length(unique(precip$Dndrmtr))
# Step 2: Prepare precipitation (keep only relevant columns)
precip_daily <- precip %>%
select(Dndrmtr, date, precipitation) %>%
rename(Dendro_number = Dndrmtr,
Date = date)
# Find date range of dendrometer data
date_range <- range(daily_variation$Date, na.rm = TRUE)
# Clip precip to fall within that range
precip_clipped <- precip_daily %>%
filter(Date >= date_range[1] & Date <= date_range[2])
####evapo
#add the climate dataset
evapo <- read_csv("/scratch/ope4/BIO_599/Dendro Climate Points/evapotranspiration_time_series.csv")
summary(evapo)
length(unique(evapo$Dndrmtr))
##interpolate to daily instead of every 8 days
# Make sure date is Date type
evapo <- evapo %>%
mutate(date = as.Date(date))
# Interpolate daily for each dendrometer
evapo_daily <- evapo %>%
group_by(Dndrmtr) %>%
arrange(date) %>%
# Create full daily sequence for each dendrometer
complete(date = seq(min(date), max(date), by = "1 day")) %>%
# Interpolate evapotranspiration
mutate(evapotranspiration = na.approx(evapotranspiration, x = date, maxgap = Inf)) %>%
ungroup()
# Step 2: Prepare precipitation (keep only relevant columns)
evapo_daily <- evapo_daily %>%
select(Dndrmtr, date, evapotranspiration) %>%
rename(Dendro_number = Dndrmtr,
Date = date)
# Find date range of dendrometer data
date_range <- range(daily_variation$Date, na.rm = TRUE)
# Clip precip to fall within that range
evapo_clipped <- evapo_daily %>%
filter(Date >= date_range[1] & Date <= date_range[2])
#### soil moisture
#add the climate dataset
soil <- read_csv("/scratch/ope4/BIO_599/Dendro Climate Points/soil_moisture_time_series.csv")
summary(soil)
length(unique(soil$Dndrmtr))
# Step 2: Prepare precipitation (keep only relevant columns)
soil <- soil %>%
select(Dndrmtr, date, soil_moisture_am) %>%
rename(Dendro_number = Dndrmtr,
Date = date)
# Find date range of dendrometer data
date_range <- range(daily_variation$Date, na.rm = TRUE)
# Clip precip to fall within that range
soil_clipped <- soil %>%
filter(Date >= date_range[1] & Date <= date_range[2])
merged <- reduce(list(soil_clipped, evapo_clipped, precip_clipped), left_join, by = c("Dendro_number", "Date"))
colnames(merged)
# Step 3: Merge
merged_data <- daily_variation %>%
left_join(merged, by = c("Dendro_number", "Date"))
## Step 4: test for trend in daily variation of dendrometer
check_trend <- function(x, alpha = 0.05) {
# Drop NAs
x <- x[!is.na(x)]
# Require at least 14 points for decompose (2 periods if freq=7)
if (length(x) < 14) {
return(data.frame(Trend = "not enough data", Slope = NA))
}
# Turn into time series
ts <- ts(x, frequency = 7)
# Perform additive decomposition
decomp_add <- decompose(ts, type = "additive")
# Use the trend component (remove NAs first)
trend_vals <- decomp_add$trend
trend_vals <- trend_vals[!is.na(trend_vals)]
if (length(trend_vals) < 3) {
return(data.frame(Trend = "not enough trend data", Slope = NA))
}
mk <- trend::mk.test(trend_vals)
sen <- trend::sens.slope(trend_vals)
slope <- sen$estimates
# Determine trend direction
if (mk$p.value < alpha) {
if (slope > 0) {
return(data.frame(Trend = "increasing", Slope = slope))
} else if (slope < 0) {
return(data.frame(Trend = "decreasing", Slope = slope))
}
}
return(data.frame(Trend = "stable", Slope = slope))
}
## Apply by Dendro_number
trend_results <- merged_data %>%
group_by(Dendro_number) %>%
summarise(
tmp = list(check_trend(TWD)),
.groups = "drop"
) %>%
tidyr::unnest_wider(tmp)  # expands Trend and Slope into separate columns
table(trend_results$Trend)
## Merge back with main data
trend_all <- merged_data %>%
left_join(trend_results, by = "Dendro_number") %>%
mutate(Trend = Trend)  # keep trend label for each record
summer_2025 <- read.csv("/scratch/ope4/BIO_599/SUMMER/SUMMER_2025.csv")
summer_2024 <- read.csv("/scratch/ope4/BIO_599/SUMMER/SUMMER_2024.csv")
colnames(summer_2025)
colnames(summer_2024)
# Convert FW and DW to numeric if they are not
summer_2025$FW <- as.numeric(summer_2025$FW)
# Replace commas with dots (for decimal), convert empty strings to NA
summer_2025$DW <- as.numeric(ifelse(summer_2025$DW == "", NA, gsub(",", ".", summer_2025$DW)))
summer_2025$LDMC <- summer_2025$DW/summer_2025$FW
summer_2024$FW <- as.numeric(summer_2024$FW)
summer_2024$DW <- as.numeric(summer_2024$DW)
summer_2024$LDMC <- summer_2024$DW/summer_2024$FW
summer_2024$DBH <- summer_2024$DBH * 2.54
summer_2025 <- summer_2025 |>
dplyr::select(-X.1, -X.2, -X.3, -X.4, -FW, -DW, -Species) |>
dplyr::filter(!is.na(REPS))
summer_2024 <- summer_2024 |>
dplyr::select(-TW, -FW, -DW, -Species) |>
dplyr::filter(!is.na(REPS))
colnames(summer_2025)
colnames(summer_2024)
summary(summer_2025)
summary(summer_2024)
# Extract Tree_name and coordinates from summer_2025
coords_2025 <- summer_2025 %>%
select(Tree_name, X, Y) %>%
distinct()  # keep only one row per Tree_name
# Join X and Y into summer_2024
summer_2024 <- summer_2024 %>%
left_join(coords_2025, by = "Tree_name")
# Row-bind the two datasets
merged_summer <- bind_rows(summer_2024, summer_2025)
##look at summary stat
summary(merged_summer)
# Look at the distribution of samples for each factor
table(merged_summer[ , c("SP_CODE", "PLOT")])
#EDA
# Select numeric columns that could be predictors
predictors <- merged_summer %>%
select(DBH, Height, WP, LWC, RWC, LT, LDMC)
# Correlation matrix (pairwise, excluding NAs)
cor_matrix <- cor(predictors, use = "pairwise.complete.obs")
# Print the correlation matrix
library(GGally)
print(round(cor_matrix, 2))
#GGally::ggpairs(predictors)
##get the absolute value of LWC
merged_summer$LWC <- abs(merged_summer$LWC)
merged_summer$WP <- -abs(merged_summer$WP)
# Look at the distribution of continuous
hist(merged_summer$DBH)
hist(merged_summer$Height)
hist(merged_summer$WP)
hist(merged_summer$LWC)
hist(merged_summer$RWC)
hist(merged_summer$LT)
hist(merged_summer$LDMC)
#boxplot
boxplot(merged_summer$DBH)
boxplot(merged_summer$Height)
boxplot(merged_summer$WP)
boxplot(merged_summer$LWC)
boxplot(merged_summer$RWC)
boxplot(merged_summer$LT)
boxplot(merged_summer$LDMC)
# Select only Dendro_number and Trend from trend_all
trend_subset <- trend_all %>%
select(Dendro_number, Trend, Slope) |>
distinct()
# Join Trend into merged_summer by matching dendrometer numbers
merged_summer <- merged_summer %>%
left_join(trend_subset, by = c("Dendrometer" = "Dendro_number"))
merged_summer <- merged_summer %>%
filter(!is.na(Trend))  %>%
filter(Trend != "not enough data")
length(unique(merged_summer$Dendrometer))
summary(merged_summer)
# Summarise predictors by Year and Tree_name
merged_summary <- merged_summer %>%
group_by(Tree_name, Time, Year) %>%
summarise(
PLOT = first(PLOT),
SP_CODE = first(SP_CODE),
Trend = first(Trend),
Slope = first(Slope),
Stress_Level = first(Stress_Level),
DBH = mean(DBH, na.rm = TRUE),
Height = mean(Height, na.rm = TRUE),
LWC = mean(LWC, na.rm = TRUE),
RWC = mean(RWC, na.rm = TRUE),
LT = mean(LT, na.rm = TRUE),
WP = mean(WP, na.rm = TRUE),
LDMC = mean(LDMC, na.rm = TRUE),
.groups = "drop"
)
##scale all predictors
##scale the varaibes
merged_summary <- merged_summary %>%
mutate(across(c(LWC, LDMC, DBH, Height, RWC, LT, WP),
~scale(.),
.names = "z_{.col}"))
summary(merged_summary)
# Remove rows with NAs in predictors
model_data <- merged_summary %>%
filter(!is.na(z_DBH) & !is.na(z_Height) & !is.na(z_LWC) & !is.na(z_WP) & !is.na(z_LDMC) & !is.na(Trend))
summary(model_data)
##linear model
model_data$Stress_Level <- factor(model_data$Stress_Level, ordered = TRUE)
lm_1 <- lm (Slope~z_WP + z_DBH + z_LWC + z_LDMC + z_Height + Stress_Level, data = model_data )
summary(lm_1)
gls_1 <- gls(Slope~z_WP + z_DBH + z_LWC + z_LDMC + z_Height + Stress_Level, data = model_data )
#summary(gls_1)
M1.nested <- lme(
fixed = Slope ~ z_WP + z_DBH + z_LWC + z_LDMC + z_Height + Stress_Level,
random = ~1 | PLOT / SP_CODE, # nested random effects: SPECIES within PLOT
data = model_data,
method = "REML"
)
#summary(M1.nested)
#compare new (model with variance by species and plot) and old model (model without any variance structure)
anova(gls_1, M1.nested)
#Random slopes for species
M1.species= lme(Slope ~ z_WP + z_DBH + z_LWC + z_LDMC + z_Height + Stress_Level, random=~1|SP_CODE,
data = model_data, method="REML")
#summary(M1.species)
#for plots instead
M1.plot <- lme(Slope ~ z_WP + z_DBH + z_LWC + z_LDMC + z_Height + Stress_Level, random=~1|PLOT,
data = model_data, method="REML")
#summary(M1.plot)
anova(gls_1, M1.nested, M1.species, M1.plot)
#summary(M1.nested)
lme1_ml <- update(M1.nested, method = "ML")
drop1(lme1_ml, test = "Chisq")
#Refit with REML and validate
#After selecting the optimal fixed structure, refit the model using REML for final coefficient estimates.
lme_final <- update(M1.nested, fixed = Slope ~ z_LWC + Stress_Level,
method = "REML")
summary(lme_final)
tab_model(lme_final, show.se=TRUE)
check_model(lme_final)
# Get predicted values from the model for danger
pred <- ggeffects::ggpredict(lme_final, terms = "z_LWC")
# Plot predictions with confidence intervals
plot(pred, show_data = TRUE) +
labs(x = "LWC (g)",
y = "Predicted change in TWD (De_trend slope)",
title = "Predicted relationship between LWC and TWD") +
theme_minimal()
#full model with all fixed and random effects
#Check for assumption violations:
#- Homogeneity of residuals.
#- Normality.
#- Outliers.
plot(resid(M1.nested) ~ model_data$z_LWC, xlab = "LWC", ylab = "Normalized residuals")+abline(h = 0, lty = 2)
plot(M1.nested)
check_model(M1.nested)
##model from model selection
#Check for assumption violations:
#- Homogeneity of residuals.
#- Normality.
#- Outliers.
plot(lme_final)
check_model(lme_final)
gls_2 <- gls(Slope~z_WP + z_DBH + z_LWC + z_LDMC + z_Height + Stress_Level + SP_CODE, data = model_data )
#summary(gls_2)
M1.Tree_random <- lme(
Slope ~ z_WP + z_DBH + z_LWC + z_LDMC + z_Height + Stress_Level + SP_CODE,
random = ~1 | PLOT,
method = "REML",
na.action = na.omit,
data = model_data
)
summary(M1.Tree_random)
tab_model(M1.Tree_random)
#compare new (model with variance by species and plot) and old model (model without any variance structure)
anova(gls_2, M1.Tree_random)
#summary(M1.nested)
lme2_ml <- update(M1.Tree_random, method = "ML")
drop1(lme2_ml, test = "Chisq")
#Refit with REML and validate
#After selecting the optimal fixed structure, refit the model using REML for final coefficient estimates.
lme_final_2 <- update(M1.Tree_random, fixed = Slope ~ z_LWC + Stress_Level + SP_CODE,
method = "REML")
summary(lme_final_2)
tab_model(lme_final_2, show.se=TRUE)
# Stress Level range
stress <- seq(0, 10, by = 0.1)
# Coefficients from your model
intercept <- 1.25
cubic_coef <- 2.64
quartic_coef <- -2.36
# Standard errors for cubic + quartic (approximation)
cubic_se <- 1.10
quartic_se <- 1.07
# Predicted Slope
predicted <- intercept + cubic_coef * stress^3 + quartic_coef * stress^4
# Approximate 95% CI using standard errors of the cubic + quartic terms
ci_upper <- predicted + 1.96 * sqrt(cubic_se^2 + quartic_se^2)
ci_lower <- predicted - 1.96 * sqrt(cubic_se^2 + quartic_se^2)
# Create a data frame for ggplot
df <- data.frame(stress = stress, predicted = predicted,
ci_upper = ci_upper, ci_lower = ci_lower)
# Plot
ggplot(df, aes(x = stress, y = predicted)) +
geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), fill = "lightblue", alpha = 0.4) +
geom_line(color = "black", size = 1.5) +
labs(
x = "Stress Level (0 = dead, 10 = healthy)",
y = "Predicted Slope",
title = "Effect of Stress Level on Slope (3rd + 4th-degree)"
) +
theme_minimal(base_size = 14) +
theme(
panel.border = element_rect(color = "black", fill = NA, linewidth = 1.2)
)
# LWC range (standardized, z-scores)
# We'll pick a reasonable range, e.g., -3 to +3 SD
lwc <- seq(-3, 3, by = 0.1)
# Coefficient and intercept
intercept <- 1.25  # from your model
lwc_coef <- -0.47
lwc_se <- 0.20
# Predicted Slope
predicted <- intercept + lwc_coef * lwc
# 95% CI
ci_upper <- predicted + 1.96 * lwc_se
ci_lower <- predicted - 1.96 * lwc_se
# Data frame
df <- data.frame(lwc = lwc, predicted = predicted,
ci_upper = ci_upper, ci_lower = ci_lower)
# Plot
ggplot(df, aes(x = lwc, y = predicted)) +
geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), fill = "pink", alpha = 0.4) +
geom_line(color = "black", size = 1.5) +
labs(
x = "z LWC (standardized leaf water content)",
y = "Predicted Slope",
title = "Effect of LWC on Slope"
) +
theme_minimal(base_size = 14)+
theme(
panel.border = element_rect(color = "black", fill = NA, linewidth = 1.2)
)
library(ggplot2)
# Create a data frame with species effects
species <- c("ABLA","JUMO","JUOS","PIED","PILE","PIPO","PIPU","PIST","PSME","QUEM","QUGA","QUHY")
estimate <- c(-1.11,-1.62,-4.19,-2.35,1.72,-3.58,0.19,-2.81,1.49,-6.85,-0.82,-1.47)
se <- c(2.16,1.46,1.18,1.65,2.08,0.97,1.16,1.07,0.96,1.47,1.10,1.37)
# Calculate 95% CI
ci_upper <- estimate + 1.96*se
ci_lower <- estimate - 1.96*se
# Identify significance
significant <- ifelse(ci_lower * ci_upper > 0, "Yes", "No")
# Data frame
df <- data.frame(species, estimate, ci_lower, ci_upper, significant)
# Reorder species by estimate for nicer plotting
df$species <- factor(df$species, levels = df$species[order(df$estimate)])
# Plot
ggplot(df, aes(x = estimate, y = species, color = significant)) +
geom_point(size = 3) +
geom_errorbarh(aes(xmin = ci_lower, xmax = ci_upper), height = 0.2) +
geom_vline(xintercept = 0, linetype = "dashed", color = "gray") +
scale_color_manual(values = c("Yes" = "pink", "No" = "black")) +
labs(
x = "Effect on TWD Slope (Estimate ± 95% CI)",
y = "Species code",
title = "Species Effects on TWD Slope"
) +
theme_minimal(base_size = 14)+
theme(
panel.border = element_rect(color = "black", fill = NA, linewidth = 1.2)
)
##model from model selection
#Check for assumption violations:
#- Homogeneity of residuals.
#- Normality.
#- Outliers.
plot(lme_final_2)
check_model(lme_final_2)
install.packages("see")
R.home()
.libPaths(c("/home/ope4/R/4.4.0", .libPaths()))
library(see)
.libPaths()
.libPaths(c("/home/ope4/R/4.4.0", .libPaths()))
.libPaths(c("/home/ope4/R/4.4.0", .libPaths()))
library(see)
.libPaths(c("/home/ope4/R/4.4.0", .libPaths()))
library(see)
